<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Theory Visualizer</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM via ESM -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.3s ease-out forwards;
        }
        
        body { background-color: #0f172a; margin: 0; overflow-y: auto; } /* Slate 900 */

        /* SVG Styles */
        .node-transition { transition: fill 0.3s ease, stroke 0.3s ease; }
        .line-transition { transition: stroke 0.3s ease, stroke-width 0.3s ease; }
        
        /* Cursors */
        .grab-cursor { cursor: grab; }
        .grab-cursor:active { cursor: grabbing; }
        
        /* Node specific cursor */
        .node-interactive { cursor: grab; }
        .node-interactive:active { cursor: grabbing; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Network, RotateCcw, ZoomIn, ZoomOut, Maximize, 
            Hash, ArrowRight, Share2, Circle, Activity, 
            Split, CircleDot, RefreshCw, Settings, LayoutGrid, Check
        } from 'lucide-react';

        // -- Constraints Logic --
        const CONFLICTS = {
            // Structures
            null: ['connected', 'complete', 'cycle', 'cyclic', 'regular', 'bipartite', 'acyclic', 'disconnected'],
            trivial: ['disconnected', 'cycle', 'cyclic', 'bipartite', 'complete', 'regular'],
            cycle: ['null', 'disconnected', 'acyclic', 'complete', 'trivial'], // Cycle is incompatible with Acyclic
            complete: ['null', 'disconnected', 'acyclic', 'bipartite', 'cycle', 'regular'], // K_n is regular, but simplifying conflict to avoid complexity
            
            // Properties
            connected: ['disconnected', 'null'],
            disconnected: ['connected', 'complete', 'cycle', 'trivial', 'regular'],
            acyclic: ['cyclic', 'cycle', 'complete', 'regular'],
            cyclic: ['acyclic', 'null', 'trivial'],
            bipartite: ['null', 'complete', 'trivial', 'cycle'],
            regular: ['null', 'disconnected', 'acyclic', 'trivial', 'complete']
        };

        const GRAPH_TYPES = [
            { id: 'directed', label: 'Directed', icon: ArrowRight, category: 'modifier' },
            { id: 'weighted', label: 'Weighted', icon: Hash, category: 'modifier' },
            { id: 'null', label: 'Null', icon: Circle, category: 'structure' },
            { id: 'trivial', label: 'Trivial', icon: CircleDot, category: 'structure' },
            { id: 'complete', label: 'Complete', icon: Share2, category: 'structure' },
            { id: 'cycle', label: 'Cycle', icon: RefreshCw, category: 'structure' },
            { id: 'connected', label: 'Connected', icon: Network, category: 'property' },
            { id: 'disconnected', label: 'Disconnected', icon: Split, category: 'property' },
            { id: 'acyclic', label: 'Acyclic', icon: ArrowRight, category: 'property' },
            { id: 'cyclic', label: 'Cyclic', icon: RefreshCw, category: 'property' },
            { id: 'bipartite', label: 'Bipartite', icon: Split, category: 'property' },
            { id: 'regular', label: 'Regular', icon: Activity, category: 'property' },
        ];

        const GraphVisualizer = () => {
            // -- URL Params Helper --
            const getInitialState = () => {
                const params = new URLSearchParams(window.location.search);
                
                // Parse Size
                const sizeParam = params.get('size');
                let initialSize = 8;
                if (sizeParam) {
                    const parsed = parseInt(sizeParam, 10);
                    if (!isNaN(parsed) && parsed >= 2 && parsed <= 20) initialSize = parsed;
                }

                // Parse Density
                const densityParam = params.get('density');
                let initialDensity = 0.5;
                if (densityParam) {
                    const parsed = parseFloat(densityParam);
                    if (!isNaN(parsed) && parsed >= 0 && parsed <= 1) initialDensity = parsed;
                }

                // Parse Properties
                const propsParam = params.get('properties');
                let initialTypes = new Set(['connected']);
                if (propsParam) {
                    const types = propsParam.split(',').map(s => s.trim().toLowerCase());
                    const validTypes = types.filter(t => GRAPH_TYPES.some(gt => gt.id === t));
                    if (validTypes.length > 0) initialTypes = new Set(validTypes);
                }

                return { size: initialSize, density: initialDensity, types: initialTypes };
            };

            const initialState = getInitialState();

            // -- State --
            const [selectedTypes, setSelectedTypes] = useState(initialState.types);
            const [nodeCount, setNodeCount] = useState(initialState.size);
            const [density, setDensity] = useState(initialState.density);
            const [graph, setGraph] = useState({ nodes: [], edges: [] });
            
            // Zoom & Pan
            const [zoom, setZoom] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [draggingNode, setDraggingNode] = useState(null);
            const lastMousePos = useRef({ x: 0, y: 0 });

            const CANVAS_WIDTH = 900;
            const CANVAS_HEIGHT = 600; 

            // -- Colors --
            const COLORS = {
                default: '#334155', // Slate 700
                highlight: '#8b5cf6', // Violet 500
                setA: '#0ea5e9', // Sky 500
                setB: '#10b981', // Emerald 500
                edgeDefault: '#475569', // Slate 600
                text: '#e2e8f0'
            };

            // -- Helper: Constraints --
            const isTypeDisabled = (typeId) => {
                for (let selected of selectedTypes) {
                    // Check direct conflicts defined in CONFLICTS
                    if (CONFLICTS[selected] && CONFLICTS[selected].includes(typeId)) return true;
                    // Check strict structure exclusivity (only 1 structure at a time)
                    const typeCat = GRAPH_TYPES.find(t => t.id === typeId).category;
                    const selectedCat = GRAPH_TYPES.find(t => t.id === selected).category;
                    if (typeCat === 'structure' && selectedCat === 'structure' && typeId !== selected) return true;
                }
                return false;
            };

            const toggleType = (typeId) => {
                if (isTypeDisabled(typeId)) return;
                
                const newSet = new Set(selectedTypes);
                if (newSet.has(typeId)) {
                    newSet.delete(typeId);
                } else {
                    newSet.add(typeId);
                }
                setSelectedTypes(newSet);
            };

            // -- Physics Layout --
            const runForceLayout = (nodes, edges, width, height) => {
                const isDisconnected = selectedTypes.has('disconnected');
                const isBipartite = selectedTypes.has('bipartite');

                const iterations = 300; 
                const repulsion = 8000; 
                const springLength = selectedTypes.has('complete') ? 250 : 120; 
                const k = 0.05; 
                const damping = 0.85;
                const centerForce = 0.02; 

                let velocities = nodes.map(() => ({ x: 0, y: 0 }));

                for (let i = 0; i < iterations; i++) {
                    // Center Gravity
                    nodes.forEach((node, idx) => {
                        let targetX = width / 2;
                        let targetY = height / 2;
                        if (isDisconnected || isBipartite) {
                            targetX = node.group === 'A' ? width * 0.3 : width * 0.7;
                        }
                        const dx = targetX - node.x;
                        const dy = targetY - node.y;
                        velocities[idx].x += dx * centerForce;
                        velocities[idx].y += dy * centerForce;
                    });

                    // Repulsion
                    for (let a = 0; a < nodes.length; a++) {
                        for (let b = 0; b < nodes.length; b++) {
                            if (a === b) continue;
                            const dx = nodes[a].x - nodes[b].x;
                            const dy = nodes[a].y - nodes[b].y;
                            let distSq = dx * dx + dy * dy || 1;
                            const force = repulsion / distSq; 
                            velocities[a].x += (dx / Math.sqrt(distSq)) * force;
                            velocities[a].y += (dy / Math.sqrt(distSq)) * force;
                        }
                    }

                    // Attraction
                    edges.forEach(edge => {
                        const sIdx = nodes.findIndex(n => n.id === edge.source);
                        const tIdx = nodes.findIndex(n => n.id === edge.target);
                        if (sIdx === -1 || tIdx === -1) return;
                        const dx = nodes[tIdx].x - nodes[sIdx].x;
                        const dy = nodes[tIdx].y - nodes[sIdx].y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        const force = (dist - springLength) * k;
                        velocities[sIdx].x += (dx / dist) * force;
                        velocities[sIdx].y += (dy / dist) * force;
                        velocities[tIdx].x -= (dx / dist) * force;
                        velocities[tIdx].y -= (dy / dist) * force;
                    });

                    // Apply
                    nodes.forEach((node, idx) => {
                        node.x += velocities[idx].x;
                        node.y += velocities[idx].y;
                        velocities[idx].x *= damping;
                        velocities[idx].y *= damping;
                        const p = 50;
                        node.x = Math.max(p, Math.min(width - p, node.x));
                        node.y = Math.max(p, Math.min(height - p, node.y));
                    });
                }
            };

            // -- Generator Logic --
            const generateGraph = useCallback(() => {
                let nodes = [];
                let edges = [];
                
                const isTrivial = selectedTypes.has('trivial');
                const isNull = selectedTypes.has('null');
                const isComplete = selectedTypes.has('complete');
                const isCycle = selectedTypes.has('cycle');
                const isBipartite = selectedTypes.has('bipartite');
                const isDisconnected = selectedTypes.has('disconnected');
                const isAcyclic = selectedTypes.has('acyclic');
                const isConnected = selectedTypes.has('connected');
                const isRegular = selectedTypes.has('regular');
                const isWeighted = selectedTypes.has('weighted');
                const isDirected = selectedTypes.has('directed');

                const count = isTrivial ? 1 : nodeCount;

                // 1. Create Nodes
                for (let i = 0; i < count; i++) {
                    nodes.push({ 
                        id: i, 
                        x: CANVAS_WIDTH / 2 + (Math.random() - 0.5) * 100, 
                        y: CANVAS_HEIGHT / 2 + (Math.random() - 0.5) * 100, 
                        label: String.fromCharCode(65 + i),
                        group: 'default' 
                    });
                }

                // 2. Assign Groups (for Bipartite/Disconnected)
                if (isBipartite || isDisconnected) {
                    const split = Math.floor(count / 2);
                    nodes.forEach((n, i) => n.group = i < split ? 'A' : 'B');
                }

                // 3. Helper to add edges
                const addEdge = (u, v, weight = null) => {
                    if (u === v) return;
                    const exists = edges.some(e => 
                        (e.source === u && e.target === v) || 
                        (!isDirected && e.source === v && e.target === u)
                    );
                    if (!exists) edges.push({ source: u, target: v, weight });
                };

                // 4. Generate Edges based on Structure/Constraints
                if (isNull) {
                    // No edges
                } else if (isComplete) {
                    for (let i = 0; i < count; i++) {
                        for (let j = i + 1; j < count; j++) {
                            addEdge(i, j); 
                        }
                    }
                } else if (isCycle) {
                    for (let i = 0; i < count; i++) addEdge(i, (i + 1) % count);
                } else {
                    // Random / Density Based Generation
                    
                    if (isRegular) {
                         // Rough approximation for visualization: if dense, make 4-regular, else 2-regular
                         for(let i=0; i<count; i++) addEdge(i, (i+1)%count);
                         if(density > 0.4 && count >= 5 && count % 2 === 0) {
                             for(let i=0; i<count; i++) addEdge(i, (i+2)%count);
                         }
                    } else if (isBipartite) {
                         // Bipartite Random G(n, p) logic
                         const setA = nodes.filter(n => n.group === 'A');
                         const setB = nodes.filter(n => n.group === 'B');
                         
                         setA.forEach(u => {
                             setB.forEach(v => {
                                 if (Math.random() < density) addEdge(u.id, v.id);
                             });
                         });
                         
                         // Ensure Bipartite has at least one edge if density is too low but not zero?
                         // The user might want empty if density 0, so leave it.
                    } else {
                        // Standard Random G(n, p) logic
                        for(let i=0; i<count; i++) {
                            for(let j=i+1; j<count; j++) {
                                // For directed, we check both directions if density applies
                                if (isDirected) {
                                     if(Math.random() < density) addEdge(i, j);
                                     if(Math.random() < density) addEdge(j, i);
                                } else {
                                     if(Math.random() < density) addEdge(i, j);
                                }
                            }
                        }
                    }
                }

                // 5. Enforce Disconnected (Cut edges between groups)
                if (isDisconnected && !isBipartite && !isNull && count > 1) {
                    edges = edges.filter(e => {
                        const sGrp = nodes[e.source].group;
                        const tGrp = nodes[e.target].group;
                        return sGrp === tGrp;
                    });
                }

                // 6. Enforce Acyclic (Remove cycles)
                if (isAcyclic && !isNull) {
                     if (isDirected) {
                         // Force direction i < j
                         edges = edges.filter(e => e.source < e.target);
                     } else {
                         // Kruskal-ish logic to prevent cycles
                         edges = [];
                         const parent = Array.from({length: count}, (_, i) => i);
                         const find = (i) => {
                             while(i !== parent[i]) i = parent[i];
                             return i;
                         };
                         const union = (i, j) => {
                             const rootI = find(i);
                             const rootJ = find(j);
                             if(rootI !== rootJ) {
                                 parent[rootI] = rootJ;
                                 return true;
                             }
                             return false;
                         };
                         
                         // Candidate edges based on density
                         let candidates = [];
                         for(let i=0; i<count; i++) 
                            for(let j=i+1; j<count; j++) 
                                if(Math.random() < density) candidates.push([i, j]);
                         
                         candidates.forEach(([u, v]) => {
                             if(union(u, v)) addEdge(u, v);
                         });
                     }
                }

                // 7. Enforce Connected (Ensure minimum path)
                if (isConnected && !isNull && !isDisconnected && count > 1) {
                    // Check connectivity. If not connected, add spanning edges.
                    // Simple approach: Add 0-1-2... line regardless
                    for(let i=0; i<count-1; i++) {
                         addEdge(i, i+1);
                    }
                }

                // 8. Weights
                if (isWeighted) {
                    edges = edges.map(e => ({ ...e, weight: Math.floor(Math.random() * 9) + 1 }));
                }

                runForceLayout(nodes, edges, CANVAS_WIDTH, CANVAS_HEIGHT);
                return { nodes, edges };
            }, [selectedTypes, nodeCount, density]);

            // -- Effects --
            useEffect(() => {
                regenerate();
            }, [selectedTypes, nodeCount, density]);

            const regenerate = () => {
                const newGraph = generateGraph();
                setGraph(newGraph);
            };

            // -- Handlers --
            const handleZoomIn = (e) => { e.stopPropagation(); setZoom(z => Math.min(z * 1.2, 4)); };
            const handleZoomOut = (e) => { e.stopPropagation(); setZoom(z => Math.max(z / 1.2, 0.5)); };
            const handleFitView = (e) => { e.stopPropagation(); setZoom(1); setPan({ x: 0, y: 0 }); };

            const handleCanvasMouseDown = (e) => { setIsPanning(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
            const handleNodeMouseDown = (e, nodeId) => { e.stopPropagation(); setDraggingNode(nodeId); lastMousePos.current = { x: e.clientX, y: e.clientY }; };

            const handleMouseMove = (e) => {
                const dx = e.clientX - lastMousePos.current.x;
                const dy = e.clientY - lastMousePos.current.y;
                lastMousePos.current = { x: e.clientX, y: e.clientY };

                if (draggingNode !== null) {
                    setGraph(prev => ({
                        ...prev,
                        nodes: prev.nodes.map(n => n.id === draggingNode ? { ...n, x: n.x + dx / zoom, y: n.y + dy / zoom } : n)
                    }));
                } else if (isPanning) {
                    setPan(p => ({ x: p.x + dx, y: p.y + dy }));
                }
            };

            const handleMouseUp = () => { setIsPanning(false); setDraggingNode(null); };

            // -- Render Helpers --
            const getNodeColor = (node) => {
                const isBipartite = selectedTypes.has('bipartite');
                const isDisconnected = selectedTypes.has('disconnected');
                if (isBipartite) return node.group === 'A' ? COLORS.setA : COLORS.setB;
                if (isDisconnected) return node.group === 'A' ? COLORS.setA : COLORS.highlight;
                return COLORS.default;
            };

            const isDirected = selectedTypes.has('directed');
            
            // Build Description
            const activeLabels = GRAPH_TYPES.filter(t => selectedTypes.has(t.id)).map(t => t.label);
            const description = activeLabels.length > 0 
                ? `${activeLabels.join(', ')} Graph` 
                : "Undirected Graph";

            return (
                React.createElement("div", { className: "flex flex-col items-center justify-center min-h-screen bg-slate-900 text-slate-100 font-sans p-4 sm:p-8" },
                    
                    /* Title */
                    React.createElement("div", { className: "w-full max-w-7xl mb-6 flex items-center gap-3 justify-start" },
                        React.createElement(Network, { size: 32, className: "text-violet-400" }),
                        React.createElement("h1", { className: "text-2xl sm:text-3xl font-bold text-violet-400 whitespace-nowrap tracking-tight" }, "Graph")
                    ),

                    /* Main Layout */
                    React.createElement("div", { className: "flex flex-col lg:flex-row gap-6 w-full max-w-7xl items-start h-full" },
                        
                        /* Sidebar (Left) */
                        React.createElement("div", { className: "w-full lg:w-72 flex flex-col gap-4 shrink-0" },
                            
                            /* Controls Card */
                            React.createElement("div", { className: "bg-slate-800 rounded-xl border border-slate-700 p-5 shadow-lg flex flex-col gap-4" },
                                React.createElement("div", { className: "flex items-center gap-2 text-slate-400 text-xs font-bold uppercase tracking-wider mb-1" },
                                    React.createElement(Settings, { size: 14 }), "Settings"
                                ),
                                React.createElement("button", { 
                                    onClick: regenerate,
                                    className: "w-full p-3 bg-violet-600 hover:bg-violet-500 text-white rounded-xl shadow-lg shadow-violet-900/50 transition-all hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 font-bold"
                                }, 
                                    React.createElement(RotateCcw, { size: 18 }), "Regenerate"
                                ),
                                React.createElement("div", { className: "h-px w-full bg-slate-700/50 my-1" }),
                                
                                /* Node Slider */
                                React.createElement("div", { className: "flex flex-col gap-2" },
                                    React.createElement("div", { className: "flex justify-between items-center" },
                                        React.createElement("span", { className: "text-xs text-slate-400" }, "Size"),
                                        React.createElement("span", { className: "text-xs font-mono text-emerald-300 bg-emerald-900/30 px-2 py-0.5 rounded" }, nodeCount)
                                    ),
                                    React.createElement("input", {
                                        type: "range", min: "2", max: "20", step: "1",
                                        value: nodeCount,
                                        onChange: (e) => setNodeCount(Number(e.target.value)),
                                        disabled: selectedTypes.has('trivial'),
                                        className: "w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-emerald-500 disabled:opacity-50"
                                    })
                                ),

                                /* Density Slider */
                                React.createElement("div", { className: "flex flex-col gap-2" },
                                    React.createElement("div", { className: "flex justify-between items-center" },
                                        React.createElement("span", { className: "text-xs text-slate-400" }, "Density"),
                                        React.createElement("span", { className: "text-xs font-mono text-purple-300 bg-purple-900/30 px-2 py-0.5 rounded" }, density.toFixed(2))
                                    ),
                                    React.createElement("input", {
                                        type: "range", min: "0", max: "1", step: "0.1",
                                        value: density,
                                        onChange: (e) => setDensity(Number(e.target.value)),
                                        disabled: selectedTypes.has('null') || selectedTypes.has('trivial') || selectedTypes.has('complete') || selectedTypes.has('cycle'),
                                        className: "w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-purple-500 disabled:opacity-50"
                                    })
                                )
                            ),

                            /* Combinational Types Card */
                            React.createElement("div", { className: "bg-slate-800 rounded-xl border border-slate-700 p-5 shadow-lg flex flex-col gap-3 max-h-[500px] overflow-y-auto" },
                                React.createElement("div", { className: "flex items-center gap-2 text-slate-400 text-xs font-bold uppercase tracking-wider mb-1" },
                                    React.createElement(LayoutGrid, { size: 14 }), "Properties"
                                ),
                                React.createElement("div", { className: "flex flex-col gap-2" },
                                    GRAPH_TYPES.map(type => {
                                        const isSelected = selectedTypes.has(type.id);
                                        const isDisabled = isTypeDisabled(type.id);
                                        return React.createElement("button", {
                                            key: type.id,
                                            onClick: () => toggleType(type.id),
                                            disabled: isDisabled,
                                            className: `flex items-center justify-between px-3 py-2.5 rounded-lg text-xs font-bold uppercase tracking-wider transition-all border text-left ${
                                                isSelected
                                                ? "bg-violet-600/20 border-violet-500 text-violet-100" 
                                                : isDisabled 
                                                    ? "bg-slate-900/30 border-transparent text-slate-600 cursor-not-allowed"
                                                    : "bg-slate-700/30 border-transparent text-slate-400 hover:bg-slate-700 hover:text-slate-200"
                                            }`
                                        },
                                            React.createElement("div", { className: "flex items-center gap-3" },
                                                React.createElement(type.icon, { size: 16, className: isSelected ? "text-violet-400" : (isDisabled ? "text-slate-600" : "opacity-50") }),
                                                type.label
                                            ),
                                            isSelected && React.createElement(Check, { size: 14, className: "text-emerald-400" })
                                        )
                                    })
                                )
                            )
                        ),

                        /* Main Content (Right) */
                        React.createElement("div", { className: "flex-1 w-full flex flex-col gap-4" },
                            
                            /* Description Box */
                            React.createElement("div", { className: "w-full min-h-[60px] bg-slate-800 rounded-xl border border-slate-700 p-4 flex items-center justify-center shadow-lg" },
                                React.createElement("p", { className: "text-lg text-slate-100 font-medium leading-relaxed text-center animate-fade-in" }, description)
                            ),

                            /* Visualization Box */
                            React.createElement("div", { className: "w-full bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-1 sm:p-2 flex flex-col gap-4 relative overflow-hidden" },
                                
                                /* Canvas */
                                React.createElement("div", { 
                                    className: `relative w-full h-[500px] bg-slate-900 rounded-lg border border-slate-700 overflow-hidden shadow-inner ${isPanning ? 'cursor-grabbing' : 'grab-cursor'}`,
                                    onMouseDown: handleCanvasMouseDown,
                                    onMouseMove: handleMouseMove,
                                    onMouseUp: handleMouseUp,
                                    onMouseLeave: handleMouseUp
                                },
                                    React.createElement("div", { 
                                        className: "absolute inset-0 pointer-events-none opacity-20", 
                                        style: { 
                                            backgroundImage: 'radial-gradient(#475569 1px, transparent 1px)', 
                                            backgroundSize: '20px 20px',
                                            transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                                            transformOrigin: 'center'
                                        } 
                                    }),
                                    React.createElement("svg", { width: "100%", height: "100%", viewBox: `0 0 ${CANVAS_WIDTH} ${CANVAS_HEIGHT}`, className: "w-full h-full" },
                                        React.createElement("defs", null,
                                            React.createElement("marker", {
                                                id: "arrowhead", markerWidth: "12", markerHeight: "8", refX: "34", refY: "4", orient: "auto"
                                            }, React.createElement("polygon", { points: "0 0, 12 4, 0 8", fill: COLORS.edgeDefault }))
                                        ),
                                        React.createElement("g", { style: { transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, transformOrigin: 'center', transition: (isPanning || draggingNode !== null) ? 'none' : 'transform 0.1s ease-out' } },
                                            graph.edges.map((edge, idx) => {
                                                const s = graph.nodes.find(n => n.id === edge.source);
                                                const t = graph.nodes.find(n => n.id === edge.target);
                                                if (!s || !t) return null;
                                                return React.createElement("g", { key: `edge-${idx}`, className: "pointer-events-none" }, 
                                                    React.createElement("line", {
                                                        x1: s.x, y1: s.y, x2: t.x, y2: t.y,
                                                        stroke: COLORS.edgeDefault, strokeWidth: 2, strokeLinecap: "round",
                                                        markerEnd: isDirected ? "url(#arrowhead)" : undefined, className: "line-transition"
                                                    }),
                                                    (selectedTypes.has('weighted') && edge.weight) && React.createElement("g", null, 
                                                        React.createElement("circle", { cx: (s.x + t.x) / 2, cy: (s.y + t.y) / 2, r: 14, fill: "#0f172a", stroke: COLORS.highlight, strokeWidth: 2 }),
                                                        React.createElement("text", { x: (s.x + t.x) / 2, y: (s.y + t.y) / 2, dy: 5, textAnchor: "middle", fill: "#fff", fontSize: 14, fontWeight: "bold" }, edge.weight)
                                                    )
                                                );
                                            }),
                                            graph.nodes.map((node) => React.createElement("g", { 
                                                key: `node-${node.id}`, className: "node-transition node-interactive", onMouseDown: (e) => handleNodeMouseDown(e, node.id)
                                            },
                                                React.createElement("circle", { cx: node.x, cy: node.y, r: 28, fill: getNodeColor(node), stroke: draggingNode === node.id ? '#fff' : "#0f172a", strokeWidth: draggingNode === node.id ? 3 : 4, className: "node-transition shadow-xl" }),
                                                React.createElement("text", { x: node.x, y: node.y, dy: 5, textAnchor: "middle", fill: "#fff", fontWeight: "bold", fontSize: 14, className: "pointer-events-none select-none" }, node.label)
                                            ))
                                        )
                                    ),
                                    React.createElement("div", { className: "absolute bottom-4 right-4 flex flex-col gap-2 bg-slate-800/90 backdrop-blur p-2 rounded-lg shadow-xl border border-slate-700" },
                                        React.createElement("button", { onClick: handleZoomIn, className: "p-2 hover:bg-slate-700 text-slate-300 rounded" }, React.createElement(ZoomIn, { size: 20 })),
                                        React.createElement("button", { onClick: handleZoomOut, className: "p-2 hover:bg-slate-700 text-slate-300 rounded" }, React.createElement(ZoomOut, { size: 20 })),
                                        React.createElement("div", { className: "h-px bg-slate-700 w-full my-1" }),
                                        React.createElement("button", { onClick: handleFitView, className: "p-2 hover:bg-slate-700 text-violet-400 rounded" }, React.createElement(Maximize, { size: 20 }))
                                    )
                                ),

                                /* Stats */
                                React.createElement("div", { className: "w-full grid grid-cols-2 sm:grid-cols-4 gap-4 px-4 pb-4" },
                                    React.createElement("div", { className: "bg-slate-900/50 p-2 rounded-lg border border-slate-700 flex flex-col items-center" },
                                        React.createElement("span", { className: "text-[10px] text-slate-500 uppercase font-bold" }, "|V| Vertices"),
                                        React.createElement("span", { className: "text-lg font-mono text-white" }, graph.nodes.length)
                                    ),
                                    React.createElement("div", { className: "bg-slate-900/50 p-2 rounded-lg border border-slate-700 flex flex-col items-center" },
                                        React.createElement("span", { className: "text-[10px] text-slate-500 uppercase font-bold" }, "|E| Edges"),
                                        React.createElement("span", { className: "text-lg font-mono text-white" }, graph.edges.length)
                                    ),
                                    React.createElement("div", { className: "bg-slate-900/50 p-2 rounded-lg border border-slate-700 flex flex-col items-center" },
                                        React.createElement("span", { className: "text-[10px] text-slate-500 uppercase font-bold" }, "Density"),
                                        React.createElement("span", { className: "text-lg font-mono text-emerald-300" }, 
                                            graph.nodes.length > 1 
                                            ? (graph.edges.length / (graph.nodes.length * (graph.nodes.length - 1))).toFixed(2) 
                                            : "0.00"
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(GraphVisualizer));
    </script>
</body>
</html>